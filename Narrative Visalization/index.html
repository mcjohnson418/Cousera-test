<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>CS-416 Narative Visualization Project</title>
        <link rel="stylesheet" href="css/styles.css">
		<script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>
        <script src='https://unpkg.com/simple-statistics@7.7.0/dist/simple-statistics.min.js'>
        </script>
    </head>
    <body>
        <h1>Is there a relationship between Nation's Wealth and Mortality Rate of it's people? </h1>
        <div class="mainView">
            <div class="Box1">
                <h2>GDP vs Female<br> Mortality Rate</h2>
                <svg id="GDPperCapita_FemaleMortalityChart"></svg>
            </div>
            <div class="Box2">
                <h2>Correlation between GPD per Capita and<br> Female Mortality for G7 countries</h2>
                <svg id="GDPperCapita_FemaleMortalityCorrBarChart1"></svg>   
            </div>
            <div class="Box3">
                <h2>Correlation between GPD per Capita and <br>Female Mortality for some Asian countries</h2>
                <svg id="GDPperCapita_FemaleMortalityCorrBarChart2"></svg>   
            </div>
            <div class="Box4">
                <h2>Correlation between GPD per Capita and <br>Female Mortality for some African countries</h2>
                <svg id="GDPperCapita_FemaleMortalityCorrBarChart3"></svg>   
            </div>
            <div class="Box5">
                <h2>Correlation between GPD per Capita and <br>Female Mortality for some South American countries</h2>
                <svg id="GDPperCapita_FemaleMortalityCorrBarChart4"></svg>   
            </div>
           
        </div>
        <div class="BelowMainViewText">
            <p> The center coordinate for each circle is the GDP per Capita and Mortality rate. The area of the circle directly related to 
                the population. The color represents the healthcare expenditure per capita.The more green-ish the color, the higher the 
                expenditure per capita. The more purle-ish the lower the expenditure per capita.</p>
            <p> The question that always seems to come up is if there exists a linear relationship. Which leads us to the bar graphs. These 
                graphs represent correlations values between GPD per Capita and Female Mortality rates from the years 2000 to 2020. A good 
                case for linearity is cases where the values is 0.95 or greater. Anything less than that would imply non-linearity as a 
                greater possible relationship among the variables in question. In this sample group, none show anything real significant 
                candidates for a pure linear play. I highlight some countries that show correlation values greater than 0.7). 
            </p>
            <a href="page2.html" title="same dir link">Next page</a>
        </div>
    </body>
    <script>
        let WDIdataset = {};

        function loadData(){
            let promise = d3.csv("WDIData_WDIData2.csv"); //WDIData_Full Data_Scrubbed2.csv
            //return Promise.all([d3.csv("WDIData_WDIData2.csv"),
            return promise.then(AllData => {
                WDIdataset.WDIData = AllData;
                //WDIdataset.geoJSON = AllData[1]
                return WDIdataset;
            })
        }

        function groupByFemaleMortality(data) { 
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "SP.DYN.AMRT.FE"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],   
                        "Country Name": d["Country Name"],
                        "Female Mortality Rate": +d["Mortality rate, Female"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
                return result;
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function groupByMaleMortality(data) { 
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "SP.DYN.AMRT.MA"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],
                        "Country Name": d["Country Name"],
                        "Male Mortality Rate": +d["Mortality rate, Male"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
                return result;
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function groupByPopulation(data) { 
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "SP.POP.TOTL"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],
                        "Country Name": d["Country Name"],
                        "Population": +d["Total Population"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
                return result;
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function groupByLifeExpectancy(data) { 
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "SP.DYN.LE00.IN"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],
                        "Country Name": d["Country Name"],
                        "Life Expectancy": +d["Life Expectancy"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
                return result;
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function groupByGDPperCapita(data) {
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "NY.GDP.PCAP.KD"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],
                        "Country Name": d["Country Name"],
                        "Income Group": d["Income Group"],
                        "GDP per Capita": +d["GDP per capita"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
               return result
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function groupByHealthExpenditureperCapita(data) {
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "SH.XPD.CHEX.PC.CD"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],
                        "Country Name": d["Country Name"],
                        "Curr Health expenditure per cap": +d["Curr Health expenditure per cap"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
               return result
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function mergeData(GDP,MortalityRate){
            GDP = GDP.sort((a,b) => {
                return d3.ascending(a["Year"], b["Year"]);
            });

            MortalityRate = MortalityRate.sort((a,b) => {
                return d3.ascending(a["Year"], b["Year"]);
            });
            
            let mergedData = {};
            
            for (let i = 0; i < MortalityRate.length; i++) {
                if ((GDP[i]["Country Code"] === MortalityRate[i]["Country Code"]) && (GDP[i]["Year"] == MortalityRate[i]["Year"])) {
                    mergedData[i] = Object.assign({},MortalityRate[i], GDP[i]);
                }
            };
            mergedData = Object.keys(mergedData).map(key => mergedData[key]);
            mergedData = mergedData.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })   
            return mergedData;
        }
        

        function getConfig(stringValue, width, height) {
            let margin = {
                top: 10,
                bottom: 50,
                left: 70,
                right: 10
                };
            
            //The body is the area that will be occupied by the scatterplot.
            let bodyHeight = height - margin.top - margin.bottom;
            let bodyWidth = width - margin.left - margin.right; 

            //The container is the SVG where we will draw the scatterplot. 
            let container = d3.select(stringValue); 
            container.attr("width", width)
                     .attr("height", height)
            
            return { width, height, margin, bodyHeight, bodyWidth, container };
        }

        
        
        function getCircleScales(xValue, yValue, Mortality, config) {
            let { bodyWidth, bodyHeight } = config;
            
            let maximumPopulation = d3.max(Mortality, d =>{
                return d["Population"];
            });    
        
            let xScale = d3.scaleLinear()
                           .range([0, bodyWidth]) 
                           .domain([0, xValue])
             
            let yScale = d3.scaleLinear()
                           .range([0, bodyHeight])
                           .domain([yValue, 0])

            let rScale = d3.scaleLinear()
                           .range([0,50])
                           .domain([0, maximumPopulation])   

            let colorScale = d3.scaleSequential()
                               .domain([0,1])
                               .interpolator(d3.interpolateCool)
                  
            return { xScale, yScale, rScale, colorScale };
        } 

        
        function drawScatterPlot(MergedData, scales, config, Year, xString, maxHealth) {
            let {margin, container} = config; // this is equivalent to 'let margin = config.margin; let container = config.container'
            let {xScale, yScale, rScale, colorScale} = scales;
            let body = container.append("g")
                                .style("transform", `translate(${margin.left}px,${margin.top}px)`)

            let ScatterPlots = body.selectAll("circle")
                                   .data(MergedData)

            ScatterPlots.enter()
                        .append("circle")
                        .attr("cx", function(d) {
                            if (d["Year"]== Year) {
                                return xScale(d[xString])
                            } else { return 0}})
                            
                        .attr("cy", function(d) {
                            if (d["Year"]=== Year){
                                return yScale(d["GDP per Capita"])
                            } else {return 0}})
                        .attr("r", function(d) {
                            if (d["Year"]== Year) {
                                return rScale(d["Population"])
                        } else {return 0}})
                        .attr("fill", function(d) {
                             if (d["Year"]== Year){
                                 return colorScale(d["Curr Health expenditure per cap"]/maxHealth)
                             }})
                        .attr("opacity", 0.75)               
                        .append("title")
                        .text(function(d){
                             if ((d["Year"]== Year) && (xString == "Male Mortality Rate")) {
                                 return "Country Name: " + d["Country Name"] + "\n" + 
                                 "Curr Health expenditure per cap: " + d["Curr Health expenditure per cap"] + "\n" +
                                 "GDP per Capita: " + d["GDP per Capita"] + "\n" + "Population: " + d["Population"] + "\n" + 
                                 "Male Mortality Rate: " + d["Male Mortality Rate"] + "\n" +
                                 "Life Expectancy: " + d["Life Expectancy"] + "\n" + "Year: " + d["Year"];
                              } else if ((d["Year"]== Year) && (xString == "Female Mortality Rate")) {
                                 return "Country Name: " + d["Country Name"] + "\n" +
                                 "Curr Health expenditure per cap: " + d["Curr Health expenditure per cap"] + "\n" +
                                 "GDP per Capita: " + d["GDP per Capita"] + "\n" + "Population: " + d["Population"] + "\n" + 
                                 "Female Mortality Rate: " + d["Female Mortality Rate"] + "\n" +
                                 "Life Expectancy: " + d["Life Expectancy"] + "\n" + "Year: " + d["Year"];
                              }
                            else {
                                return "Country Name: " + d["Country Name"] + "\n"  +
                                 "Curr Health expenditure per cap: " + d["Curr Health expenditure per cap"] + "\n" +
                                 "GDP per Capita: " + d["GDP per Capita"] + "\n" + "Population: " + d["Population"] + "\n" + 
                                 "Life Expectancy: " + d["Life Expectancy"] + "\n" + "Year: " + d["Year"];
                            }})
            
            body.selectAll("text")
                        .data(MergedData)
                        .enter()
                        .append("text") 
                        .text(function(d) {
                            if ((d["Year"] == Year) && (d["Population"] >= 100000000)) {
                                return "." + d["Country Code"];
                            }})
                        .attr("x", function(d) {
                            return xScale(d[xString]);
                            })
			            .attr("y", function(d) {
                            return yScale(d["GDP per Capita"]);
                            })
			            .attr("font-family", "sans-serif")
			            .attr("font-size", "11px")
			            .attr("fill", "black");                                         
        }


        function drawAxesChart(mergedData, scales, config){
            let {xScale, yScale} = scales;
            let {container, margin, height} = config;

            let axisX = d3.axisBottom(xScale)
                          .ticks(5)

            container.append("g")
                     .style("transform",`translate(${margin.left}px,${height - margin.bottom}px)`)
                     .call(axisX)
                     .append("text")
                     .attr("y", 30)
                     .attr("x", 250)
                     .attr("text-anchor", "middle")
                     .attr("stroke", "black")
                     .text("Female Mortality Rate");
                     

            let axisY = d3.axisLeft(yScale)
                          
            container.append("g")
                     .style("transform",`translate(${margin.left}px,${margin.top}px)`)
                     .call(axisY)
                     .append("text")
                     .attr("transform", "rotate(0)")
                     .attr("x", -75) 
                     .attr("y", height - 280) 
                     .attr("dy", "-5.1em")
                     .attr("text-anchor", "middle")
                     .attr("stroke", "black")
                     .text("GDP per Capita");
                     
        }
       
        function SimpleCorr(data,CountryCode,MortalityRate){
            let result1 = [];
            let result2 = [];
            let X = data.reduce((X, d) => {
                if (d["Country Code"] === CountryCode){
                    result1.push(d["GDP per Capita"]);
                    result2.push(d[MortalityRate]);
                    };
                },{});   
            let Corr = ss.sampleCorrelation(result1, result2).toFixed(2);
            if (isNaN(Corr)) { 
                return 0;
            } else {return Corr }
        }

        function DrawBars(xValue, yValue, data, config){
            let { bodyWidth, bodyHeight, margin, container, height } = config; // this is equivalent to 'let margin = config.margin; let container = config.container'
            //let {xScale, yScale, rScale, colorScale} = scales;
            let body = container.append("g")
                                .style("transform", `translate(${margin.left}px,${margin.top}px)`)

            let yPad = 33;

            let yAxisBottom = margin.top + (data.length*yPad);
               

            let svg = body.selectAll("rect")
                          .data(data)

            let xScale = d3.scaleLinear()
                           .domain([-1,1])
                           .range([0,xValue*0.8])
                               
            let xAxis = d3.axisBottom(xScale)
                          .ticks(5)
                
            let yScale = d3.scaleBand()
                           .domain(data.map(d => d["Country Code"]))
                           .range([0,yAxisBottom*0.87])
                           .padding(0.2)

            let yAxis = d3.axisLeft(yScale)                              

            svg.enter()
               .append("rect")
               .attr("y", function(d) {return yScale(d["Country Code"])}) 
               .attr("height", yScale.bandwidth())
               .attr("width", function(d) {return xScale(d.Correlation)})
               .attr("fill", function(d) {
                   if (d.Correlation <= 0.7) {
                      return "rgb(42,85,153)"} else {return "rgb(169, 104, 54)"}})
               .append("title")
               .text(function(d){
                   return "Correlation Value: " + d.Correlation;
                   })       
               
            container.append("g")
               .style("transform",`translate(${margin.left}px,${yAxisBottom*0.92}px)`)
               .call(xAxis)
                   
            container.append("g")
               .style("transform",`translate(${margin.left}px,${margin.top}px)`)
               .call(yAxis)   
        }

        function CreateAnnotations(id, labeltext, titletext, xVal, yVal, dxVal, dyVal, wrap){
            const annotations = [
                {
                    note: {
                        label: labeltext,
                        title: titletext,
                        wrap: wrap
                    },
                    x: xVal,
                    y: yVal,
                    dy: dyVal,
                    dx: dxVal
                }
            ]

            const makeAnnotations = d3.annotation()
                                      .annotations(annotations)

            d3.select(id) 
                .append("g")
                .call(makeAnnotations)    

        }

                
        function showData(){
            let BoxWidth = 700;
            let BoxHeight = 600;
            let xValue = 450;
            let yValue = 65000; 
            WDIdataset.Year = 2018;

            //Preprocessing the data
            let FemaleMor = groupByFemaleMortality(WDIdataset.WDIData);
            let GDPperCap = groupByGDPperCapita(WDIdataset.WDIData);
            let Population = groupByPopulation(WDIdataset.WDIData);
            let MaleMor = groupByMaleMortality(WDIdataset.WDIData);
            let LifeExp = groupByLifeExpectancy(WDIdataset.WDIData);
            let HeatlthExp = groupByHealthExpenditureperCapita(WDIdataset.WDIData);
            
            let MergedData = mergeData(HeatlthExp,mergeData(LifeExp,mergeData(MaleMor,mergeData(Population,mergeData(FemaleMor, GDPperCap)))));
            WDIdataset.MergedData = MergedData;

            let maxHealth = d3.max(MergedData, d =>{
                return d["Curr Health expenditure per cap"];
            });
           
            //Configure and draw 
            let FemaleConfig = getConfig("#GDPperCapita_FemaleMortalityChart", BoxWidth, BoxHeight);
            let FemScales = getCircleScales(xValue, yValue, MergedData, FemaleConfig)
            drawScatterPlot(MergedData, FemScales, FemaleConfig, WDIdataset.Year, "Female Mortality Rate", maxHealth);
            drawAxesChart(MergedData, FemScales, FemaleConfig);


            let CountryNotUnique = MergedData.map(function (d) {return d["Country Code"]});
            let Country = CountryNotUnique.filter((v, i, a) => a.indexOf(v) === i);
            let Corr = [];
            //USA, CAN, FRA, GBR, ITA, JPN, DEU
            for (let c = 0; c < Country.length; c++) {
                if ((Country[c]=="USA") || (Country[c]=="CAN") || (Country[c]=="FRA") || (Country[c]=="GBR") || (Country[c]=="ITA") || (Country[c]=="JPN") || (Country[c]=="DEU")) {
                    Corr.push({"Country Code": Country[c], 
                               "Correlation": +SimpleCorr(MergedData, Country[c],"Female Mortality Rate")});
                }
            }
            
            BoxWidth = 550;
            BoxHeight = 250;
            let CorrChartConfig = getConfig("#GDPperCapita_FemaleMortalityCorrBarChart1", BoxWidth, BoxHeight);

            DrawBars(xValue, yValue, Corr, CorrChartConfig);

            //https://wits.worldbank.org/wits/wits/witshelp/content/codes/country_codes.htm


            //The large Asian economies of Hong Kong(HKG), Singapore(SGP), South Korea(KOR), China(CHN), India(IND), Australia(AUS) and Russia(RUS).
            Corr = [];
            for (let c = 0; c < Country.length; c++) {
                if ((Country[c]=="HKG") || (Country[c]=="SGP") || (Country[c]=="KOR") || (Country[c]=="CHN") || (Country[c]=="IND") || (Country[c]=="AUS") || (Country[c]=="RUS")) {
                    Corr.push({"Country Code": Country[c], "Correlation": +SimpleCorr(MergedData, Country[c],"Female Mortality Rate")});
                }
            }

            //console.log(Corr)
            BoxWidth = 550;
            BoxHeight = 250;
            CorrChartConfig = getConfig("#GDPperCapita_FemaleMortalityCorrBarChart2", BoxWidth, BoxHeight);
            DrawBars(xValue, yValue, Corr, CorrChartConfig);

            //a few from South America economies Brazil(BRA), Argentina(ARG), Chile(CHL), Bolivia(BOL), Peru(PER), Colombia(COL), and Venezuela(VEN)
            Corr = [];
            for (let c = 0; c < Country.length; c++) {
                if ((Country[c]=="BRA") || (Country[c]=="ARG") || (Country[c]=="CHL") || (Country[c]=="BOL") || (Country[c]=="PER") || (Country[c]=="COL") || (Country[c]=="VEN")) {
                    Corr.push({"Country Code": Country[c], "Correlation": +SimpleCorr(MergedData, Country[c],"Female Mortality Rate")});
                }
            }

            BoxWidth = 550;
            BoxHeight = 250;
            CorrChartConfig = getConfig("#GDPperCapita_FemaleMortalityCorrBarChart4", BoxWidth, BoxHeight);
            DrawBars(xValue, yValue, Corr, CorrChartConfig);

            //a few from Africa and Middle East economies South Africa(ZAF), Ghana(GHA), Nigeria(NGA), Turkey(TUR), Iran(IRN), Saudi Arabia(SAU), and Israel(ISR)
            Corr = [];
            for (let c = 0; c < Country.length; c++) {
                if ((Country[c]=="ZAF") || (Country[c]=="GHA") || (Country[c]=="NGA") || (Country[c]=="TUR") || (Country[c]=="IRN") || (Country[c]=="SAU") || (Country[c]=="ISR")) {
                    Corr.push({"Country Code": Country[c], "Correlation": +SimpleCorr(MergedData, Country[c],"Female Mortality Rate")});
                }
            }

            BoxWidth = 550;
            BoxHeight = 250;
            CorrChartConfig = getConfig("#GDPperCapita_FemaleMortalityCorrBarChart3", BoxWidth, BoxHeight);
            DrawBars(xValue, yValue, Corr, CorrChartConfig);

            
            
            let titletext = "The weak exponential decay hypothesis";
            let labeltext = "From the scatterplot shown, the trend seems to follow an exponential decay curve. The overall trend for the 2018 data is " +
                            "that the higher the GDP per Capita, the lower the mortality rate for females. However, there seems to be a cluster of" + 
                            "countries that buck this trend in an area enclosed arouund 12,000 GDP per Capita and Female mortality rate of 150. "
            
            let { FemChart_width, FemChart_height, margin, container } = FemaleConfig;                
            let xVal = margin.left + 470;
            let yVal = margin.top + 4;
            let dxVal = 0;
            let dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_FemaleMortalityChart", labeltext, titletext, xVal, yVal, dxVal, dyVal, 150);

            titletext = "The developed nations";
            labeltext = "As expected, the cluster around the 27,000 to 57,000 GDP per Capita and 0 to 100 mortality rate follow the " +
                        "weak hypothesis.";
            
            xVal = 220;
            yVal = 10;
            dxVal = 0;
            dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_FemaleMortalityChart", labeltext, titletext, xVal, yVal, dxVal, dyVal, 250);

            labeltext = "However, what is really noticable about this cluster is all the countries with a GDP per Capita less than USA, spend " + 
                        "significantly lower in healthcare while reporting lower mortality rates";
            
            xVal = 150;
            yVal = 150;
            dxVal = 50;
            dyVal = 10;                 

            CreateAnnotations("#GDPperCapita_FemaleMortalityChart", labeltext, titletext, xVal, yVal, dxVal, dyVal, 150);

            titletext = "Other influences";
            labeltext = "Show of the countries that are labeled developing or emerging that have lower GDP per capita show lower mortality rates then " +
                         "so called developed nations";
            xVal = 210;
            yVal = 470;
            dxVal = 160;
            dyVal = -40; 

            CreateAnnotations("#GDPperCapita_FemaleMortalityChart", labeltext, titletext, xVal, yVal, dxVal, dyVal, 150);

            titletext = "Correlation with G7";
            labeltext = "From this sample, the question of linearity does not seem to imply. Japan seems to be the somewhat of an exception.";
            
            xVal = 400;
            yVal = 10;
            dxVal = 0;
            dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_FemaleMortalityCorrBarChart1", labeltext, titletext, xVal, yVal, dxVal, dyVal, 120);

            titletext = "Correlation with Asian counties";
            labeltext = "The linearity assumption, in this sample, does not seem likely.";
            
            xVal = 400;
            yVal = 10;
            dxVal = 0;
            dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_FemaleMortalityCorrBarChart2", labeltext, titletext, xVal, yVal, dxVal, dyVal, 120);


            titletext = "Correlation with African counties";
            labeltext = "Again, any sign of linearity is small at most, in this sample. Saudi Arabia seems to be the exception.";
            
            xVal = 400;
            yVal = 10;
            dxVal = 0;
            dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_FemaleMortalityCorrBarChart3", labeltext, titletext, xVal, yVal, dxVal, dyVal, 130);

            titletext = "Correlation with S.A. counties";
            labeltext = "There seem to be some countries with a correlation value close to 0.7. But, these values do not imply a real linearity.";
            
            xVal = 400;
            yVal = 10;
            dxVal = 0;
            dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_FemaleMortalityCorrBarChart4", labeltext, titletext, xVal, yVal, dxVal, dyVal, 130);

            console.log(MergedData); 
        }

        loadData().then(showData);
        

    </script>    
</html>