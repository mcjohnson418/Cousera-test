<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>CS-416 Narative Visualization Project</title>
        <link rel="stylesheet" href="css/styles2.css">
		<script src="https://d3js.org/d3.v7.min.js"></script>
        <script src="https://rawgit.com/susielu/d3-annotation/master/d3-annotation.min.js"></script>
        <script src='https://unpkg.com/simple-statistics@7.7.0/dist/simple-statistics.min.js'>
        </script>
    </head>
    <body>
        <h1>Is there a relationship between a nationâ€™s wealth and mortality rate or is there other factors beside just wealth </h1>
        <div class="mainView">
            <div class="Box1">
                <h2>GDP vs Male<br> Mortality Rate</h2>
                <svg id="GDPperCapita_MaleMortalityChart"></svg>
            </div>
            <div class="Box2">
                <h2>Correlation between GPD per Capita and<br> Male Mortality for G7 countries</h2>
                <svg id="GDPperCapita_MaleMortalityCorrBarChart1"></svg>   
            </div>
            <div class="Box3">
                <h2>Correlation between GPD per Capita and <br>Male Mortality for some Asian countries</h2>
                <svg id="GDPperCapita_MaleMortalityCorrBarChart2"></svg>   
            </div>
            <div class="Box4">
                <h2>Correlation between GPD per Capita and <br>Male Mortality for some African countries</h2>
                <svg id="GDPperCapita_MaleMortalityCorrBarChart3"></svg>   
            </div>
            <div class="Box5">
                <h2>Correlation between GPD per Capita and <br>Male Mortality for some South American countries</h2>
                <svg id="GDPperCapita_MaleMortalityCorrBarChart4"></svg>   
            </div>
        </div>
        <div class="BelowMainViewText">
            <p> The bar graphs explores from a small sample groups rather or not there is any sign of linearity betwen GPD per Capita and 
                mortality rate. To really explore the weak hypothesis would require two things. First, we would have to fit a statistical 
                model using a probability distribution from the exponential distribution family with GDP per Capita being one of the 
                predictor variables ( along with healthcare expenditure pwer capita, population growth, personal income/economic class, 
                and maybe even political climate ) for mortality rate (where mortality rate would be the dependent variable). Then, a 
                goodness of fit analysis would determine rather the model was indeed a weak fit for the data. Second, a null hypothesis 
                test on the model would determine rather or not GPD per Capita is even a significant predictor for mortality rate. 
            </p>
            <a id="a1" href="index.html" title="same dir link">back</a>
            <a id="a2" href="page3.html" title="same dir link">Next page</a>
        </div>
    </body>
    <script>
        let WDIdataset = {};

        function loadData(){
            let promise = d3.csv("WDIData_WDIData2.csv"); //WDIData_Full Data_Scrubbed2.csv
            //return Promise.all([d3.csv("WDIData_WDIData2.csv"),
            return promise.then(AllData => {
                WDIdataset.WDIData = AllData;
                //WDIdataset.geoJSON = AllData[1]
                return WDIdataset;
            })
        }

        function groupByFemaleMortality(data) { 
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "SP.DYN.AMRT.FE"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],   
                        "Country Name": d["Country Name"],
                        "Female Mortality Rate": +d["Mortality rate, Female"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
                return result;
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function groupByMaleMortality(data) { 
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "SP.DYN.AMRT.MA"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],
                        "Country Name": d["Country Name"],
                        "Male Mortality Rate": +d["Mortality rate, Male"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
                return result;
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function groupByPopulation(data) { 
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "SP.POP.TOTL"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],
                        "Country Name": d["Country Name"],
                        "Population": +d["Total Population"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
                return result;
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function groupByLifeExpectancy(data) { 
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "SP.DYN.LE00.IN"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],
                        "Country Name": d["Country Name"],
                        "Life Expectancy": +d["Life Expectancy"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
                return result;
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function groupByGDPperCapita(data) {
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "NY.GDP.PCAP.KD"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],
                        "Country Name": d["Country Name"],
                        "Income Group": d["Income Group"],
                        "GDP per Capita": +d["GDP per capita"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
               return result
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function groupByHealthExpenditureperCapita(data) {
            Count = 0;
            let result = data.reduce((result, d) => {
                if (d["Indicator Code"] === "SH.XPD.CHEX.PC.CD"){
                    let currentData = {
                        "Country Code": d["Country Code (WDICountry.csv)"],
                        "Country Name": d["Country Name"],
                        "Curr Health expenditure per cap": +d["Curr Health expenditure per cap"],
                        "Year": +d["Year"]
                    };
                    //console.log(currentData);
                    result[Count] = currentData;
                    Count += 1;
                };
               return result
            }, {})
    
            //Need to map objects to list. It seems to work better
            result = Object.keys(result).map(key => result[key])
            result = result.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })
            return result
        }

        function mergeData(GDP,MortalityRate){
            GDP = GDP.sort((a,b) => {
                return d3.ascending(a["Year"], b["Year"]);
            });

            MortalityRate = MortalityRate.sort((a,b) => {
                return d3.ascending(a["Year"], b["Year"]);
            });
            
            let mergedData = {};
            
            for (let i = 0; i < MortalityRate.length; i++) {
                if ((GDP[i]["Country Code"] === MortalityRate[i]["Country Code"]) && (GDP[i]["Year"] == MortalityRate[i]["Year"])) {
                    mergedData[i] = Object.assign({},MortalityRate[i], GDP[i]);
                }
            };
            mergedData = Object.keys(mergedData).map(key => mergedData[key]);
            mergedData = mergedData.sort((a,b) => {
                return d3.ascending(a["Country Code"], b["Country Code"]);
            })   
            return mergedData;
        }
        

        function getConfig(stringValue, width, height) {
            let margin = {
                top: 10,
                bottom: 50,
                left: 70,
                right: 10
                };
            
            //The body is the area that will be occupied by the scatterplot.
            let bodyHeight = height - margin.top - margin.bottom;
            let bodyWidth = width - margin.left - margin.right; 

            //The container is the SVG where we will draw the scatterplot. 
            let container = d3.select(stringValue); 
            container.attr("width", width)
                     .attr("height", height)
            
            return { width, height, margin, bodyHeight, bodyWidth, container };
        }

        
        
        function getCircleScales(xValue, yValue, Mortality, config) {
            let { bodyWidth, bodyHeight } = config;
            
            let maximumPopulation = d3.max(Mortality, d =>{
                return d["Population"];
            });    
        
            let xScale = d3.scaleLinear()
                           .range([0, bodyWidth]) 
                           .domain([0, xValue])
             
            let yScale = d3.scaleLinear()
                           .range([0, bodyHeight])
                           .domain([yValue, 0])

            let rScale = d3.scaleLinear()
                           .range([0,50])
                           .domain([0, maximumPopulation])   

            let colorScale = d3.scaleSequential()
                               .domain([0,1])
                               .interpolator(d3.interpolateCool)
                  
            return { xScale, yScale, rScale, colorScale };
        } 

        
        function drawScatterPlot(MergedData, scales, config, Year, xString, maxHealth) {
            let {margin, container} = config; // this is equivalent to 'let margin = config.margin; let container = config.container'
            let {xScale, yScale, rScale, colorScale} = scales;
            let body = container.append("g")
                                .style("transform", `translate(${margin.left}px,${margin.top}px)`)

            let ScatterPlots = body.selectAll("circle")
                                   .data(MergedData)

            ScatterPlots.enter()
                        .append("circle")
                        .attr("cx", function(d) {
                            if (d["Year"]== Year) {
                                return xScale(d[xString])
                            } else { return 0}})
                            
                        .attr("cy", function(d) {
                            if (d["Year"]=== Year) {
                                return yScale(d["GDP per Capita"])
                            } else {return 0}})
                        .attr("r", function(d) {
                            if (d["Year"]== Year) {
                                return rScale(d["Population"])
                        } else {return 0}})
                        .attr("fill", function(d) {
                             if (d["Year"]== Year){
                                 return colorScale(d["Curr Health expenditure per cap"]/maxHealth)
                             }})
                        .attr("opacity", 0.75)           
                        .append("title")
                        .text(function(d){
                             if ((d["Year"]== Year) && (xString == "Male Mortality Rate")) {
                                 return "Country Name: " + d["Country Name"] + "\n" +
                                 "Curr Health expenditure per cap: " + d["Curr Health expenditure per cap"] + "\n" +
                                 "GDP per Capita: " + d["GDP per Capita"] + "\n" + "Population: " + d["Population"] + "\n" + 
                                 "Male Mortality Rate: " + d["Male Mortality Rate"] + "\n" +
                                 "Life Expectancy: " + d["Life Expectancy"] + "\n" + "Year: " + d["Year"];
                              } else if ((d["Year"]== Year) && (xString == "Female Mortality Rate")) {
                                 return "Country Name: " + d["Country Name"] + "\n" +
                                 "Curr Health expenditure per cap: " + d["Curr Health expenditure per cap"] + "\n" +
                                 "GDP per Capita: " + d["GDP per Capita"] + "\n" + "Population: " + d["Population"] + "\n" + 
                                 "Female Mortality Rate: " + d["Female Mortality Rate"] + "\n" +
                                 "Life Expectancy: " + d["Life Expectancy"] + "\n" + "Year: " + d["Year"];
                              }
                            else {
                                return "Country Name: " + d["Country Name"] + "\n" +
                                 "Curr Health expenditure per cap: " + d["Curr Health expenditure per cap"] + "\n" +
                                 "GDP per Capita: " + d["GDP per Capita"] + "\n" + "Population: " + d["Population"] + "\n" + 
                                 "Life Expectancy: " + d["Life Expectancy"] + "\n" + "Year: " + d["Year"];
                            }})
        
        body.selectAll("text")
            .data(MergedData)
            .enter()
            .append("text") 
            .text(function(d) {
                if ((d["Year"] == Year) && (d["Population"] >= 100000000)) {
                    return "." + d["Country Code"];
                }})
            .attr("x", function(d) {
                    return xScale(d[xString]);
                })
		    .attr("y", function(d) {
                    return yScale(d["GDP per Capita"]);
                })
		    .attr("font-family", "sans-serif")
		    .attr("font-size", "11px")
		    .attr("fill", "black");                                              
        }


        function drawAxesChart(mergedData, scales, config){
            let {xScale, yScale} = scales;
            let {container, margin, height} = config;

            let axisX = d3.axisBottom(xScale)
                          .ticks(5)

            container.append("g")
                     .style("transform",`translate(${margin.left}px,${height - margin.bottom}px)`)
                     .call(axisX)
                     .append("text")
                     .attr("y", 30)
                     .attr("x", 250)
                     .attr("text-anchor", "middle")
                     .attr("stroke", "black")
                     .text("Female Mortality Rate");
                     

            let axisY = d3.axisLeft(yScale)
                          

            container.append("g")
                     .style("transform",`translate(${margin.left}px,${margin.top}px)`)
                     .call(axisY)
                     .append("text")
                     .attr("transform", "rotate(0)")
                     .attr("x", -75) //-50
                     .attr("y", height - 280) //300
                     .attr("dy", "-5.1em")
                     .attr("text-anchor", "middle")
                     .attr("stroke", "black")
                     .text("GDP per Capita");
                     
        }
        
        function SimpleCorr(data,CountryCode,MortalityRate){
            let result1 = [];
            let result2 = [];
            let X = data.reduce((X, d) => {
                if (d["Country Code"] === CountryCode){
                    result1.push(d["GDP per Capita"])
                    result2.push(d[MortalityRate])
                    };
                },{});
            let Corr = ss.sampleCorrelation(result1, result2).toFixed(2);
            if (isNaN(Corr)) { 
                return 0;
            } else {return Corr }
        }

        function DrawBars(xValue, yValue, data, config){
            let { bodyWidth, bodyHeight, margin, container, height } = config; // this is equivalent to 'let margin = config.margin; let container = config.container'
            //let {xScale, yScale, rScale, colorScale} = scales;
            let body = container.append("g")
                                .style("transform", `translate(${margin.left}px,${margin.top}px)`)

            let yPad = 33;

            let yAxisBottom = margin.top + (data.length*yPad);
               

            let svg = body.selectAll("rect")
                          .data(data)

            let xScale = d3.scaleLinear()
                           .domain([-1,1])
                           .range([0,xValue*0.8])
                               
            let xAxis = d3.axisBottom(xScale)
                          .ticks(5)
                
            let yScale = d3.scaleBand()
                           .domain(data.map(d => d["Country Code"]))
                           .range([0,yAxisBottom*0.87])
                           .padding(0.2)

            let yAxis = d3.axisLeft(yScale)                              

            svg.enter()
               .append("rect")
               .attr("y", (d) => {return yScale(d["Country Code"])}) //33
               .attr("height", yScale.bandwidth())
               .attr("width", d => {return xScale(d.Correlation)})
               .attr("fill", function(d) {
                   if (d.Correlation <= 0.7) {
                      return "rgb(42,85,153)"} else {return "rgb(169, 104, 54)"}})
               .append("title")
               .text(function(d){
                   return "Correlation Value: " + d.Correlation;
                   }) 
               
            container.append("g")
               .style("transform",`translate(${margin.left}px,${yAxisBottom*0.92}px)`)
               .call(xAxis)
                   
            container.append("g")
               .style("transform",`translate(${margin.left}px,${margin.top}px)`)
               .call(yAxis)   
        }

        function CreateAnnotations(id, labeltext, titletext, xVal, yVal, dxVal, dyVal, wrap){
            const annotations = [
                {
                    note: {
                        label: labeltext,
                        title: titletext,
                        wrap: wrap
                    },
                    x: xVal,
                    y: yVal,
                    dy: dyVal,
                    dx: dxVal
                }
            ]

            const makeAnnotations = d3.annotation()
                                      .annotations(annotations)

            d3.select(id) 
                .append("g")
                .call(makeAnnotations)    

        }

                
        function showData(){
            let BoxWidth = 700;
            let BoxHeight = 600;
            let xValue = 450;
            let yValue = 65000; 
            WDIdataset.Year = 2018;

            //Preprocessing the data
            let FemaleMor = groupByFemaleMortality(WDIdataset.WDIData);
            let GDPperCap = groupByGDPperCapita(WDIdataset.WDIData);
            let Population = groupByPopulation(WDIdataset.WDIData);
            let MaleMor = groupByMaleMortality(WDIdataset.WDIData);
            let LifeExp = groupByLifeExpectancy(WDIdataset.WDIData);
            let HeatlthExp = groupByHealthExpenditureperCapita(WDIdataset.WDIData);
            
            let MergedData = mergeData(HeatlthExp,mergeData(LifeExp,mergeData(MaleMor,mergeData(Population,mergeData(FemaleMor, GDPperCap)))));
            WDIdataset.MergedData = MergedData;

            let maxHealth = d3.max(MergedData, d =>{
                return d["Curr Health expenditure per cap"];
            });
           
            //Configure and draw 
            let MaleConfig = getConfig("#GDPperCapita_MaleMortalityChart", BoxWidth, BoxHeight);
            let MaleScales = getCircleScales(xValue, yValue, MergedData, MaleConfig)
            drawScatterPlot(MergedData, MaleScales, MaleConfig, WDIdataset.Year, "Male Mortality Rate", maxHealth);
            drawAxesChart(MergedData, MaleScales, MaleConfig);


            let CountryNotUnique = MergedData.map(function (d) {return d["Country Code"]});
            let Country = CountryNotUnique.filter((v, i, a) => a.indexOf(v) === i);
            let Corr = [];
            //USA, CAN, FRA, GBR, ITA, JPN, DEU
            for (let c = 0; c < Country.length; c++) {
                if ((Country[c]=="USA") || (Country[c]=="CAN") || (Country[c]=="FRA") || (Country[c]=="GBR") || (Country[c]=="ITA") || (Country[c]=="JPN") || (Country[c]=="DEU")) {
                    Corr.push({"Country Code": Country[c], "Correlation": +SimpleCorr(MergedData, Country[c],"Male Mortality Rate")});
                }
            }
            
            BoxWidth = 550;
            BoxHeight = 250;
            let CorrChartConfig = getConfig("#GDPperCapita_MaleMortalityCorrBarChart1", BoxWidth, BoxHeight);

            DrawBars(xValue, yValue, Corr, CorrChartConfig);

            //https://wits.worldbank.org/wits/wits/witshelp/content/codes/country_codes.htm


            //The large Asian economies of Hong Kong(HKG), Singapore(SGP), South Korea(KOR), China(CHN), India(IND), Australia(AUS) and Russia(RUS).
            Corr = [];
            for (let c = 0; c < Country.length; c++) {
                if ((Country[c]=="HKG") || (Country[c]=="SGP") || (Country[c]=="KOR") || (Country[c]=="CHN") || (Country[c]=="IND") || (Country[c]=="AUS") || (Country[c]=="RUS")) {
                    Corr.push({"Country Code": Country[c], "Correlation": +SimpleCorr(MergedData, Country[c],"Male Mortality Rate")});
                }
            }

            //console.log(Corr)
            BoxWidth = 550;
            BoxHeight = 250;
            CorrChartConfig = getConfig("#GDPperCapita_MaleMortalityCorrBarChart2", BoxWidth, BoxHeight);
            DrawBars(xValue, yValue, Corr, CorrChartConfig);

            //a few from South America economies Brazil(BRA), Argentina(ARG), Chile(CHL), Bolivia(BOL), Peru(PER), Colombia(COL), and Venezuela(VEN)
            Corr = [];
            for (let c = 0; c < Country.length; c++) {
                if ((Country[c]=="BRA") || (Country[c]=="ARG") || (Country[c]=="CHL") || (Country[c]=="BOL") || (Country[c]=="PER") || (Country[c]=="COL") || (Country[c]=="VEN")) {
                    Corr.push({"Country Code": Country[c], "Correlation": +SimpleCorr(MergedData, Country[c],"Male Mortality Rate")});
                }
            }

            BoxWidth = 550;
            BoxHeight = 250;
            CorrChartConfig = getConfig("#GDPperCapita_MaleMortalityCorrBarChart4", BoxWidth, BoxHeight);
            DrawBars(xValue, yValue, Corr, CorrChartConfig);

            //a few from Africa and Middle East economies South Africa(ZAF), Ghana(GHA), Nigeria(NGA), Turkey(TUR), Iran(IRN), Saudi Arabia(SAU), and Israel(ISR)
            Corr = [];
            for (let c = 0; c < Country.length; c++) {
                if ((Country[c]=="ZAF") || (Country[c]=="GHA") || (Country[c]=="NGA") || (Country[c]=="TUR") || (Country[c]=="IRN") || (Country[c]=="SAU") || (Country[c]=="ISR")) {
                    Corr.push({"Country Code": Country[c], "Correlation": +SimpleCorr(MergedData, Country[c],"Male Mortality Rate")});
                }
            }

            BoxWidth = 550;
            BoxHeight = 250;
            CorrChartConfig = getConfig("#GDPperCapita_MaleMortalityCorrBarChart3", BoxWidth, BoxHeight);
            DrawBars(xValue, yValue, Corr, CorrChartConfig);

            let titletext = "The weak exponential decay hypothesis";
            let labeltext = "As shown in the previous page, the GDP per Capita/Mortality rate for males follows the same trend as " +
                            "GDP per Capita/Mortality rates for females.";
            
            let { MaleChart_width, MaleChart_height, margin } = MaleConfig;                
            let xVal = margin.left + 470;
            let yVal = margin.top + 4;
            let dxVal = 0;
            let dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_MaleMortalityChart", labeltext, titletext, xVal, yVal, dxVal, dyVal, 150);

            titletext = "Healthcare expenditure/GDP/Population";
            labeltext = "What is not easy to explain from the data is how are countries that spend a lot less than the USA and have " +
                        "smaller GDP per Capita than the USA, reports lower mortality rates for both sexes.";
            
            xVal = 200;
            yVal = 190;
            dxVal = 100;
            dyVal = 10;                 

            CreateAnnotations("#GDPperCapita_MaleMortalityChart", labeltext, titletext, xVal, yVal, dxVal, dyVal, 150);

            
            titletext = "Correlation with G7";
            labeltext = "The signs of linearity is small among this sample. Howver once again, Japan seems to be the exception.";
            
            xVal = 400;
            yVal = 10;
            dxVal = 0;
            dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_MaleMortalityCorrBarChart1", labeltext, titletext, xVal, yVal, dxVal, dyVal, 140);

            titletext = "Correlation with Asian counties";
            labeltext = "Linearity assumption is low amoung this sample.";
            
            xVal = 400;
            yVal = 10;
            dxVal = 0;
            dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_MaleMortalityCorrBarChart2", labeltext, titletext, xVal, yVal, dxVal, dyVal, 120);


            titletext = "Correlation with African counties";
            labeltext = "Again, sign of linearity is small at most, in this sample. Saudi Arabia seems to be the exception.";
            
            xVal = 400;
            yVal = 10;
            dxVal = 0;
            dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_MaleMortalityCorrBarChart3", labeltext, titletext, xVal, yVal, dxVal, dyVal, 130);

            titletext = "Correlation with S.A. counties";
            labeltext = "The trend here is also similar as with the female samples. Some countries come close to the 0.7 value.";
            
            xVal = 400;
            yVal = 10;
            dxVal = 0;
            dyVal = 0;                 

            CreateAnnotations("#GDPperCapita_MaleMortalityCorrBarChart4", labeltext, titletext, xVal, yVal, dxVal, dyVal, 130);

            console.log(MergedData); 

            
        }

        loadData().then(showData);
        

    </script>    
</html>